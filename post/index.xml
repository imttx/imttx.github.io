<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on MARATRIX BLOG</title>
    <link>http://maratrix.cn/post/</link>
    <description>Recent content in Posts on MARATRIX BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 14 Apr 2020 11:55:41 +0800</lastBuildDate>
    
	<atom:link href="http://maratrix.cn/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>strings.Builder 源码阅读与分析</title>
      <link>http://maratrix.cn/post/2020/04/14/strings-builder-source-note/</link>
      <pubDate>Tue, 14 Apr 2020 11:55:41 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/04/14/strings-builder-source-note/</guid>
      <description>背景之字符串拼接 在 Go 语言中，对于字符串的拼接处理有很多种方法，那么那种方法才是效率最高的呢？ str := []string{&amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;, &amp;quot;cc&amp;quot;} ss := &amp;quot;&amp;quot; for _, s := range str { ss += s } fmt.Println(ss) 相信大部分人都会使用+操作符或者fmt.Sprinf进行拼接，但要注意的是，在 Go 语言中字符串是不可变的，也就是说每次修改都会导致字符串创建、销毁、内</description>
    </item>
    
    <item>
      <title>Go Hijack黑科技</title>
      <link>http://maratrix.cn/post/2020/04/14/go-hijack-note/</link>
      <pubDate>Tue, 14 Apr 2020 11:53:21 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/04/14/go-hijack-note/</guid>
      <description>最近在看Go标准库里面的rpc源码，发现了下面一段代码： // ServeHTTP implements an http.Handler that answers RPC requests. func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) { if req.Method != &amp;quot;CONNECT&amp;quot; { w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;text/plain; charset=utf-8&amp;quot;) w.WriteHeader(http.StatusMethodNotAllowed) io.WriteString(w, &amp;quot;405 must CONNECT\n&amp;quot;) return } conn, _, err := w.(http.Hijacker).Hijack() //注意看这里 if err != nil { log.Print(&amp;quot;rpc hijacking &amp;quot;, req.RemoteAddr, &amp;quot;: &amp;quot;, err.Error()) return } io.WriteString(conn, &amp;quot;HTTP/1.0 &amp;quot;+connected+&amp;quot;\n\n&amp;quot;) server.ServeConn(conn) } 这是一段接管 HTTP 连接的代码，所谓的接管 HTTP 连接是指这里接管了 HTTP 的 TCP 连接，也就是说 Golang 的内置 HTTP 库和 HTTPServer 库将不</description>
    </item>
    
    <item>
      <title>Nginx基于权重的轮询算法实现</title>
      <link>http://maratrix.cn/post/2020/04/14/smooth-weighted-round-robin/</link>
      <pubDate>Tue, 14 Apr 2020 11:47:28 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/04/14/smooth-weighted-round-robin/</guid>
      <description>Nginx平滑的基于权重轮询算法描述为： Algorithm is as follows: on each peer selection we increase current_weight of each eligible peer by its weight, select peer with greatest current_weight and reduce its current_weight by total number of weight points distributed among peers. 算法执行2步，选择出1个当前节点： 每个节点，用它们的当前值加上它们自己的权重。 选择当前值最大的节点为选中节点，并把它的当前值减去所有节点的权重总和。 例如{a:5, b:1, c:</description>
    </item>
    
    <item>
      <title>Rust学习笔记007-所有权</title>
      <link>http://maratrix.cn/post/2020/02/06/007-rust-ownership-notes/</link>
      <pubDate>Thu, 06 Feb 2020 10:01:58 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/02/06/007-rust-ownership-notes/</guid>
      <description>什么是所有权 Rust的核心功能（之一）就是所有权，其令 Rust 无需垃圾回收即可保障内存安全。 所有运行的程序都必须管理其使用计算机内存的方式： 一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存； 在另一些语言中，程序员必须亲自分配和释放内存。 Rust 则选择了第三种方式：通过所有权系</description>
    </item>
    
    <item>
      <title>Rust学习笔记006-控制流</title>
      <link>http://maratrix.cn/post/2020/02/05/006-rust-control-notes/</link>
      <pubDate>Wed, 05 Feb 2020 10:00:51 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/02/05/006-rust-control-notes/</guid>
      <description>if表达式 Rust的if...else if ... else基本语法和大多编程语言类似，这里不再赘述。 if 条件 { //... } else if 条件 { //... } else { //... } 注意，这里的条件表达式不包含()括号，直接写表达式即可： let number = 3; if number &amp;gt; 0 { println!(&amp;quot;number was three&amp;quot;); } 在let中使用if 因为 if 是一个表达式，我们可以在 let 语句的右侧使用它： fn main()</description>
    </item>
    
    <item>
      <title>Rust学习笔记005-函数</title>
      <link>http://maratrix.cn/post/2020/02/05/005-rust-functions-notes/</link>
      <pubDate>Wed, 05 Feb 2020 09:59:52 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/02/05/005-rust-functions-notes/</guid>
      <description>函数定义 使用fn关键字定义函数； 函数名使用snake_case规范命名； 函数可以定义在main函数之前或之后，Rust 不关心函数定义于何处； fn test_function(a: i32, b: bool) -&amp;gt; u32 { //... } 函数参数 函数可以定义多个参数，使用逗号,分隔； 参数是函数签名的一部分； 参数必须指定类型； 包含语句和表达式的函数体 函数体由</description>
    </item>
    
    <item>
      <title>Rust学习笔记004-数据类型</title>
      <link>http://maratrix.cn/post/2020/02/05/004-rust-types-notes/</link>
      <pubDate>Wed, 05 Feb 2020 09:51:09 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/02/05/004-rust-types-notes/</guid>
      <description>前言 Rust是静态类型语言，在编译时就必须知道所有变量的类型。 两种方式确定类型： 根据值及使用方式，编译器通常可以推断出我们想要用的类型； 当多种类型均有可能时，必须增加类型注解； 如下代码，不加类型编译会报错。 let guess: u32 = &amp;quot;42&amp;quot;.parse().expect(&amp;quot;Not a number!&amp;quot;); 标量类型 整型 浮点型 布尔类型 字符类型 整型 长度 有符号 无符号 8bit i8 u8</description>
    </item>
    
    <item>
      <title>Rust学习笔记003-变量与可变性</title>
      <link>http://maratrix.cn/post/2020/02/04/003-rust-variable-notes/</link>
      <pubDate>Tue, 04 Feb 2020 09:49:40 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/02/04/003-rust-variable-notes/</guid>
      <description>变量声明 语法格式： let 变量名: 变量类型 = 变量值; let var: i32 = 123; 有几点要注意： 以关键字let开头，类型一定跟在冒号:后面； 变量必须先声明，初始化后才能使用； 初始化 Rust中，每个变量必须被合理的初始化后才能被使用。使用未初始化的变量，不能被编译通过。 let x: i32; println!(&amp;quot;x = {}&amp;quot;, x); //运行报错：use of possibly-uninitialized</description>
    </item>
    
    <item>
      <title>Rust学习笔记002-编程概念</title>
      <link>http://maratrix.cn/post/2020/02/04/002-rust-notes/</link>
      <pubDate>Tue, 04 Feb 2020 09:45:34 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/02/04/002-rust-notes/</guid>
      <description>标识符 Rust 中的名称被称为 “标识符”（“identifier”），它们可以是任意非空的 ASCII 字符串，不过有如下限制： 要么是： 第一个字符是字母。 其它字符是字母数字或者 _。 或者是： 第一个字符是 _。 标识符需多于一个字符。单独的_不是标识符。 其它字符是字母数字或者 _。 原始标识符 有时出于某种原因你</description>
    </item>
    
    <item>
      <title>Rust学习笔记001-初相识</title>
      <link>http://maratrix.cn/post/2020/02/04/001-rust-hello-world-notes/</link>
      <pubDate>Tue, 04 Feb 2020 09:45:20 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/02/04/001-rust-hello-world-notes/</guid>
      <description>Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety. Rust是一门系统级编程语言，具有三个特点： 运行快 防止段错误 保证线程安全 C和C++是业界最流行的系统编程语言，Rust的定位与之类似，但是增加了安全性。 版本和发布策略 语义化版本号 Rust编译器的版本号采用了“语义化版本号”规划。版本格式为：主版本号</description>
    </item>
    
    <item>
      <title>Rust学习笔记000-安装</title>
      <link>http://maratrix.cn/post/2020/02/04/000-rust-install-notes/</link>
      <pubDate>Tue, 04 Feb 2020 09:40:42 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/02/04/000-rust-install-notes/</guid>
      <description>今天正式开始学Rust。 安装 学习一门新语言，第一件事当然是先安装。官方推荐使用rustup工具来管理安装，并提供一键安装命令，只需要在终端执行以下命令即可： curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 其实就是，先下载安装rustup，然后使用rustip来安装Rust。 环境变量 安装脚本自动将 Rust 加入系统 PATH 环境</description>
    </item>
    
    <item>
      <title>Go踩坑系列 | 为什么request.URL.Scheme取不到值</title>
      <link>http://maratrix.cn/post/2019/09/28/go-url-scheme-notes/</link>
      <pubDate>Sat, 28 Sep 2019 10:18:10 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2019/09/28/go-url-scheme-notes/</guid>
      <description>遇到的问题 最近在阅读echo框架的源码，发现context.go文件在读取请求的scheme时是单独封装了个方法。就很奇怪，go语言标准库不是自带了方法吗，干嘛不用？ 于是写了段代码来验证： func main() { http.HandleFunc(&amp;quot;/foo&amp;quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, &amp;quot;Scheme:&amp;quot;, r.URL.Scheme) }) log.Fatal(http.ListenAndServe(&amp;quot;:9000&amp;quot;, nil)) } 当我们请求http://127.0.0.1:9000/foo</description>
    </item>
    
    <item>
      <title>Go踩坑系列 | json标准库string标签你用对了么</title>
      <link>http://maratrix.cn/post/2019/09/05/go-json-string-tag-notes/</link>
      <pubDate>Thu, 05 Sep 2019 10:15:11 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2019/09/05/go-json-string-tag-notes/</guid>
      <description>工作中，我们会经常用到Go自带的json标准库，使用也很简单，具体用法这里不多说。 有的时候上游传过来的字段是string类型的，但是我们却想用变成int来使用。 本来用一个json:&amp;quot;,string&amp;quot; 就可以支持了，如果不知道golang的这些小技巧，就要大费周章</description>
    </item>
    
    <item>
      <title>Go服务平滑重启实践</title>
      <link>http://maratrix.cn/post/2019/07/31/go-overseer-notes/</link>
      <pubDate>Wed, 31 Jul 2019 10:12:16 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2019/07/31/go-overseer-notes/</guid>
      <description>为了实现Golang业务的平滑重载，研究了一下github上比较成熟的解决方案，找到如下三个库： grace endless overseer 大致看了一下源码，grace和endless是比较像的，实现步骤如下： 监听信号 收到信号时fork子进程（使用相同的启动命令），将服务监听的socket文件描述符传递给子进程 子进程</description>
    </item>
    
    <item>
      <title>go:linkname用法</title>
      <link>http://maratrix.cn/post/2019/07/12/go-linkname-syntax-notes/</link>
      <pubDate>Fri, 12 Jul 2019 10:10:42 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2019/07/12/go-linkname-syntax-notes/</guid>
      <description>什么是go:linkname 这里引用Go官方文档的解释： //go:linkname localname importpath.name The //go:linkname directive instructs the compiler to use “importpath.name” as the object file symbol name for the variable or function declared as “localname” in the source code. Because this directive can subvert the type system and package modularity, it is only enabled in files that have imported &amp;ldquo;unsafe&amp;rdquo;. 翻译过来就是： 这个指令告诉编译器为函数或者变量localname使用i</description>
    </item>
    
  </channel>
</rss>