<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on MARATRIX BLOG</title>
    <link>https://maratrix.cn/post/</link>
    <description>Recent content in Posts on MARATRIX BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 16 Sep 2020 19:27:00 +0800</lastBuildDate>
    
	<atom:link href="https://maratrix.cn/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux dd 命令使用详解</title>
      <link>https://maratrix.cn/post/2020/09/16/linux-comm-dd/</link>
      <pubDate>Wed, 16 Sep 2020 19:27:00 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/09/16/linux-comm-dd/</guid>
      <description>dd 命令介绍 Linux dd 命令用于读取、转换并输出数据。 dd 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。 dd 命令使用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。可</description>
    </item>
    
    <item>
      <title>Go源码阅读 | channel 设计与实现</title>
      <link>https://maratrix.cn/post/2020/08/25/go-channel-source-read/</link>
      <pubDate>Tue, 25 Aug 2020 22:40:45 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/08/25/go-channel-source-read/</guid>
      <description>本文基于 Go1.14 源码阅读 1package runtime 2 3// 此文件实现了 Go 的 channel 4 5// 变种: 6// c.sendq 和 c.recvq 中至少一个为空，除非是 unbuffered channle 和单个 goroutine 7// 阻塞在 select 语句中同时使用发送和接受的这种情况。这时 c.sendq 和 c.recvq 的长度由 8// select 语句的大小限制。 9// 10// 对于 buffered chann</description>
    </item>
    
    <item>
      <title>Go源码阅读 | context.Context设计与实现</title>
      <link>https://maratrix.cn/post/2020/07/12/go-context-source-read/</link>
      <pubDate>Sun, 12 Jul 2020 16:55:45 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/07/12/go-context-source-read/</guid>
      <description>本文基于 Go1.14.2 Go 自带的 context 包设计的很巧妙，最近阅读了下源码实现，可谓是短小精悍，很值得投入时间去学习。 什么是 context Go1.7 开始引入的 context 标准库包，主要用来在协程之间传递上下文信息，包括：取消信号、超时控制、截止时间、k</description>
    </item>
    
    <item>
      <title>如何借助Go指令生成随机数</title>
      <link>https://maratrix.cn/post/2020/06/14/go-fast-random/</link>
      <pubDate>Sun, 14 Jun 2020 18:36:57 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/06/14/go-fast-random/</guid>
      <description>如何在 Go 开发中高效而又快速地生成随机数呢？相信大家首先想到的就是使用标准库自带的 math/rand 包，或者使用开源的第三方包（比如 github.com/valyala/fastrand）来实现。 Go 运行时自带了 runtime.fastrand 函数来</description>
    </item>
    
    <item>
      <title>[转]简单围观一下有趣的//go:指令</title>
      <link>https://maratrix.cn/post/2020/06/13/go-directive-syntax/</link>
      <pubDate>Sat, 13 Jun 2020 09:11:02 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/06/13/go-directive-syntax/</guid>
      <description>前言 如果你平时有翻看源码的习惯，你肯定会发现。咦，怎么有的方法上面总是写着 //go: 这类指令呢。他们到底是干嘛用的？ 今天我们一同揭开他们的面纱，我将简单给你介绍一下，它们都负责些什么。 go:linkname 1//go:linkname localname importpath.name 该指令指示编译器</description>
    </item>
    
    <item>
      <title>Go源码阅读 | sync.WaitGroup设计与实现</title>
      <link>https://maratrix.cn/post/2020/04/25/go-sync-waitgroup-notes/</link>
      <pubDate>Sat, 25 Apr 2020 20:50:34 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/25/go-sync-waitgroup-notes/</guid>
      <description>前言 当我们的程序在运行过程中需要执行多个子任务时，我们可以利用 Go 协程并发地执行这些子任务，然后等待它们执行结束，从而缩短程序串行执行的耗费时间。Go 语言标准库自带了该组件：sync.WaitGroup</description>
    </item>
    
    <item>
      <title>Go源码阅读 | sync.Once设计与实现</title>
      <link>https://maratrix.cn/post/2020/04/21/go-sync-once-source-notes/</link>
      <pubDate>Tue, 21 Apr 2020 11:55:18 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/21/go-sync-once-source-notes/</guid>
      <description>介绍 sync.Once 是 Go 官方自带的标准库，实现了 exactly once 的功能。通过使用 sync.Once 我们可以很方便地实现单例模式，确保对象只被初始化一次。 首先看一个 sync.Once 的 Go 官方例子，源码链接在这里： 1var once sync.Once 2onceBody := func() { 3 fmt.Println(&amp;#34;Only once&amp;#34;) 4} 5done := make(chan bool) 6for i := 0; i &amp;lt; 10; i++ {</description>
    </item>
    
    <item>
      <title>Go中如何实现禁止拷贝</title>
      <link>https://maratrix.cn/post/2020/04/20/go-nocopy-notes/</link>
      <pubDate>Mon, 20 Apr 2020 21:56:22 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/20/go-nocopy-notes/</guid>
      <description>背景 最近看 Go 标准库源码时经常遇到禁止拷贝对象的使用场景，比如当我们使用 strings.Builder 或者 sync.Pool 对象的时候会被禁止拷贝，这是如何实现的呢？ 主要有以下两种方式： 方式一：手动检查 这种需要我们在运行时通过 copyCheck 方法来检查是否发生</description>
    </item>
    
    <item>
      <title>Go源码阅读 | strings.Builder设计与实现</title>
      <link>https://maratrix.cn/post/2020/04/14/strings-builder-source-note/</link>
      <pubDate>Tue, 14 Apr 2020 11:55:41 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/14/strings-builder-source-note/</guid>
      <description>背景之字符串拼接 在 Go 语言中，对于字符串的拼接处理有很多种方法，那么那种方法才是效率最高的呢？ 1str := []string{&amp;#34;aa&amp;#34;, &amp;#34;bb&amp;#34;, &amp;#34;cc&amp;#34;} 2ss := &amp;#34;&amp;#34; 3for _, s := range str { 4 ss += s 5} 6fmt.Println(ss) 相信大部分人都会使用+操作符或者fmt.Sprinf进行拼接，但要</description>
    </item>
    
    <item>
      <title>Go Hijack黑科技</title>
      <link>https://maratrix.cn/post/2020/04/14/go-hijack-note/</link>
      <pubDate>Tue, 14 Apr 2020 11:53:21 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/14/go-hijack-note/</guid>
      <description>最近在看Go标准库里面的rpc源码，发现了下面一段代码： 1// ServeHTTP implements an http.Handler that answers RPC requests. 2func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) { 3 if req.Method != &amp;#34;CONNECT&amp;#34; { 4 w.Header().Set(&amp;#34;Content-Type&amp;#34;, &amp;#34;text/plain; charset=utf-8&amp;#34;) 5 w.WriteHeader(http.StatusMethodNotAllowed) 6 io.WriteString(w, &amp;#34;405 must CONNECT\n&amp;#34;) 7 return 8 } 9 conn, _, err := w.(http.Hijacker).Hijack() //注意看这里 10 if err != nil { 11 log.Print(&amp;#34;rpc hijacking &amp;#34;, req.RemoteAddr, &amp;#34;: &amp;#34;, err.Error()) 12 return 13 } 14 io.WriteString(conn, &amp;#34;HTTP/1.0</description>
    </item>
    
    <item>
      <title>Nginx基于权重的轮询算法实现</title>
      <link>https://maratrix.cn/post/2020/04/14/smooth-weighted-round-robin/</link>
      <pubDate>Tue, 14 Apr 2020 11:47:28 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/14/smooth-weighted-round-robin/</guid>
      <description>Nginx平滑的基于权重轮询算法描述为： Algorithm is as follows: on each peer selection we increase current_weight of each eligible peer by its weight, select peer with greatest current_weight and reduce its current_weight by total number of weight points distributed among peers. 算法执行2步，选择出1个当前节点： 每个节点，用它们的当前值加上它们自己的权重。 选择当前值</description>
    </item>
    
    <item>
      <title>Rust学习笔记007-所有权</title>
      <link>https://maratrix.cn/post/2020/02/06/007-rust-ownership-notes/</link>
      <pubDate>Thu, 06 Feb 2020 10:01:58 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/06/007-rust-ownership-notes/</guid>
      <description>什么是所有权 Rust的核心功能（之一）就是所有权，其令 Rust 无需垃圾回收即可保障内存安全。 所有运行的程序都必须管理其使用计算机内存的方式： 一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；</description>
    </item>
    
    <item>
      <title>Rust学习笔记006-控制流</title>
      <link>https://maratrix.cn/post/2020/02/05/006-rust-control-notes/</link>
      <pubDate>Wed, 05 Feb 2020 10:00:51 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/05/006-rust-control-notes/</guid>
      <description>if表达式 Rust的if...else if ... else基本语法和大多编程语言类似，这里不再赘述。 1if 条件 { 2 //... 3} else if 条件 { 4 //... 5} else { 6 //... 7} 注意，这里的条件表达式不包含()括号，直接写表达式即可： 1let number = 3; 2if number</description>
    </item>
    
    <item>
      <title>Rust学习笔记005-函数</title>
      <link>https://maratrix.cn/post/2020/02/05/005-rust-functions-notes/</link>
      <pubDate>Wed, 05 Feb 2020 09:59:52 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/05/005-rust-functions-notes/</guid>
      <description>函数定义 使用fn关键字定义函数； 函数名使用snake_case规范命名； 函数可以定义在main函数之前或之后，Rust 不关心函数定义于何处； 1fn test_function(a: i32, b: bool) -&amp;gt; u32 { 2 //... 3} 函数参数 函数可以定义多个参数，使用逗号</description>
    </item>
    
    <item>
      <title>Rust学习笔记004-数据类型</title>
      <link>https://maratrix.cn/post/2020/02/05/004-rust-types-notes/</link>
      <pubDate>Wed, 05 Feb 2020 09:51:09 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/05/004-rust-types-notes/</guid>
      <description>前言 Rust是静态类型语言，在编译时就必须知道所有变量的类型。 两种方式确定类型： 根据值及使用方式，编译器通常可以推断出我们想要用的类型； 当多种类型均有可能时，必须增加类型注解； 如下代码，不加类型编译会</description>
    </item>
    
    <item>
      <title>Rust学习笔记003-变量与可变性</title>
      <link>https://maratrix.cn/post/2020/02/04/003-rust-variable-notes/</link>
      <pubDate>Tue, 04 Feb 2020 09:49:40 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/04/003-rust-variable-notes/</guid>
      <description>变量声明 语法格式： 1let 变量名: 变量类型 = 变量值; 2let var: i32 = 123; 有几点要注意： 以关键字let开头，类型一定跟在冒号:后面； 变量必须先声明，初始化后才能使用； 初始化 Rust中，每个变量必须被合理的初始化后才能被</description>
    </item>
    
    <item>
      <title>Rust学习笔记002-编程概念</title>
      <link>https://maratrix.cn/post/2020/02/04/002-rust-notes/</link>
      <pubDate>Tue, 04 Feb 2020 09:45:34 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/04/002-rust-notes/</guid>
      <description>标识符 Rust 中的名称被称为 “标识符”（“identifier”），它们可以是任意非空的 ASCII 字符串，不过有如下限制： 要么是： 第一个字符是字母。 其它字符是字母数字或者 _。 或者是： 第一个字符是 _。 标识符需多于一个</description>
    </item>
    
    <item>
      <title>Rust学习笔记001-初相识</title>
      <link>https://maratrix.cn/post/2020/02/04/001-rust-hello-world-notes/</link>
      <pubDate>Tue, 04 Feb 2020 09:45:20 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/04/001-rust-hello-world-notes/</guid>
      <description>Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety. Rust是一门系统级编程语言，具有三个特点： 运行快 防止段错误 保证线程安全 C和C++是业界最流行的系统编程语言，Rust的定位与之类似，但是增加了安全性。 版本和发布策略 语</description>
    </item>
    
    <item>
      <title>Rust学习笔记000-安装</title>
      <link>https://maratrix.cn/post/2020/02/04/000-rust-install-notes/</link>
      <pubDate>Tue, 04 Feb 2020 09:40:42 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/04/000-rust-install-notes/</guid>
      <description>今天正式开始学Rust。 安装 学习一门新语言，第一件事当然是先安装。官方推荐使用rustup工具来管理安装，并提供一键安装命令，只需要在终端执行以下命令即可： 1curl --proto &amp;#39;=https&amp;#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 其实就是，先下载安装rust</description>
    </item>
    
    <item>
      <title>Go踩坑系列 | 为什么request.URL.Scheme取不到值</title>
      <link>https://maratrix.cn/post/2019/09/28/go-url-scheme-notes/</link>
      <pubDate>Sat, 28 Sep 2019 10:18:10 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2019/09/28/go-url-scheme-notes/</guid>
      <description>遇到的问题 最近在阅读echo框架的源码，发现context.go文件在读取请求的scheme时是单独封装了个方法。就很奇怪，go语言标准库不是自带了方法吗，干嘛不用？ 于是写了段代码来验证： 1func main() { 2 http.HandleFunc(&amp;#34;/foo&amp;#34;, func(w</description>
    </item>
    
    <item>
      <title>Go踩坑系列 | json标准库string标签你用对了么</title>
      <link>https://maratrix.cn/post/2019/09/05/go-json-string-tag-notes/</link>
      <pubDate>Thu, 05 Sep 2019 10:15:11 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2019/09/05/go-json-string-tag-notes/</guid>
      <description>工作中，我们会经常用到Go自带的json标准库，使用也很简单，具体用法这里不多说。 有的时候上游传过来的字段是string类型的，但是我们却想用变成int来使用。 本来用一个json:&amp;quot;,str</description>
    </item>
    
    <item>
      <title>Go服务平滑重启实践</title>
      <link>https://maratrix.cn/post/2019/07/31/go-overseer-notes/</link>
      <pubDate>Wed, 31 Jul 2019 10:12:16 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2019/07/31/go-overseer-notes/</guid>
      <description>为了实现Golang业务的平滑重载，研究了一下github上比较成熟的解决方案，找到如下三个库： grace endless overseer 大致看了一下源码，grace和endless是比较像的，实现步骤如下： 监听信号 收到信号时fork子</description>
    </item>
    
    <item>
      <title>go:linkname用法</title>
      <link>https://maratrix.cn/post/2019/07/12/go-linkname-syntax-notes/</link>
      <pubDate>Fri, 12 Jul 2019 10:10:42 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2019/07/12/go-linkname-syntax-notes/</guid>
      <description>什么是go:linkname 这里引用Go官方文档的解释： //go:linkname localname importpath.name The //go:linkname directive instructs the compiler to use “importpath.name” as the object file symbol name for the variable or function declared as “localname” in the source code. Because this directive can subvert the type system and package modularity, it is only enabled in</description>
    </item>
    
  </channel>
</rss>