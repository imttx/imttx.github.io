<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go源码阅读 on MARATRIX BLOG</title>
    <link>https://maratrix.cn/tags/Go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
    <description>Recent content in Go源码阅读 on MARATRIX BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 06 Jan 2021 23:13:10 +0800</lastBuildDate><atom:link href="https://maratrix.cn/tags/Go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>uber-go/ratelimit 源码阅读</title>
      <link>https://maratrix.cn/post/2021/01/06/uber-go-ratelimit-read/</link>
      <pubDate>Wed, 06 Jan 2021 23:13:10 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/01/06/uber-go-ratelimit-read/</guid>
      <description>限流器是微服务中不可缺少的组件，起着保护下游服务负载过高、保证服务稳定性的作用。 限流器的实现方式有很多，最常见的有漏桶、令牌桶两种： 漏桶是指我们有一个一直装满了水的桶，每过固定的一段时间即向外漏一滴水</description>
    </item>
    
    <item>
      <title>Go源码阅读 | channel 设计与实现</title>
      <link>https://maratrix.cn/post/2020/08/25/go-channel-source-read/</link>
      <pubDate>Tue, 25 Aug 2020 22:40:45 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/08/25/go-channel-source-read/</guid>
      <description>本文基于 Go1.14 源码阅读 1package runtime 2 3// 此文件实现了 Go 的 channel 4 5// 变种: 6// c.sendq 和 c.recvq 中至少一个为空，除非是 unbuffered channle 和单个 goroutine 7// 阻塞在 select 语句中同时使用发送和接受的这种情况。这时 c.sendq 和 c.recvq 的长度由 8// select 语句的大小限制。 9// 10// 对于 buffered chann</description>
    </item>
    
    <item>
      <title>Go源码阅读 | context.Context设计与实现</title>
      <link>https://maratrix.cn/post/2020/07/12/go-context-source-read/</link>
      <pubDate>Sun, 12 Jul 2020 16:55:45 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/07/12/go-context-source-read/</guid>
      <description>本文基于 Go1.14.2 Go 自带的 context 包设计的很巧妙，最近阅读了下源码实现，可谓是短小精悍，很值得投入时间去学习。 什么是 context Go1.7 开始引入的 context 标准库包，主要用来在协程之间传递上下文信息，包括：取消信号、超时控制、截止时间、k</description>
    </item>
    
    <item>
      <title>Go源码阅读 | sync.WaitGroup设计与实现</title>
      <link>https://maratrix.cn/post/2020/04/25/go-sync-waitgroup-notes/</link>
      <pubDate>Sat, 25 Apr 2020 20:50:34 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/25/go-sync-waitgroup-notes/</guid>
      <description>前言 当我们的程序在运行过程中需要执行多个子任务时，我们可以利用 Go 协程并发地执行这些子任务，然后等待它们执行结束，从而缩短程序串行执行的耗费时间。Go 语言标准库自带了该组件：sync.WaitGroup</description>
    </item>
    
    <item>
      <title>Go源码阅读 | sync.Once设计与实现</title>
      <link>https://maratrix.cn/post/2020/04/21/go-sync-once-source-notes/</link>
      <pubDate>Tue, 21 Apr 2020 11:55:18 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/21/go-sync-once-source-notes/</guid>
      <description>介绍 sync.Once 是 Go 官方自带的标准库，实现了 exactly once 的功能。通过使用 sync.Once 我们可以很方便地实现单例模式，确保对象只被初始化一次。 首先看一个 sync.Once 的 Go 官方例子，源码链接在这里： 1var once sync.Once 2onceBody := func() { 3 fmt.Println(&amp;#34;Only once&amp;#34;) 4} 5done := make(chan bool) 6for i := 0; i &amp;lt; 10; i++ {</description>
    </item>
    
    <item>
      <title>Go源码阅读 | strings.Builder设计与实现</title>
      <link>https://maratrix.cn/post/2020/04/14/strings-builder-source-note/</link>
      <pubDate>Tue, 14 Apr 2020 11:55:41 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/14/strings-builder-source-note/</guid>
      <description>背景之字符串拼接 在 Go 语言中，对于字符串的拼接处理有很多种方法，那么那种方法才是效率最高的呢？ 1str := []string{&amp;#34;aa&amp;#34;, &amp;#34;bb&amp;#34;, &amp;#34;cc&amp;#34;} 2ss := &amp;#34;&amp;#34; 3for _, s := range str { 4 ss += s 5} 6fmt.Println(ss) 相信大部分人都会使用+操作符或者fmt.Sprinf进行拼接，但要</description>
    </item>
    
  </channel>
</rss>
