<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on MARATRIX BLOG</title>
    <link>http://maratrix.cn/categories/Go/</link>
    <description>Recent content in Go on MARATRIX BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 14 Apr 2020 11:55:41 +0800</lastBuildDate>
    
	<atom:link href="http://maratrix.cn/categories/Go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>strings.Builder 源码阅读与分析</title>
      <link>http://maratrix.cn/post/2020/04/14/strings-builder-source-note/</link>
      <pubDate>Tue, 14 Apr 2020 11:55:41 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/04/14/strings-builder-source-note/</guid>
      <description>背景之字符串拼接 在 Go 语言中，对于字符串的拼接处理有很多种方法，那么那种方法才是效率最高的呢？ str := []string{&amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;, &amp;quot;cc&amp;quot;} ss := &amp;quot;&amp;quot; for _, s := range str { ss += s } fmt.Println(ss) 相信大部分人都会使用+操作符或者fmt.Sprinf进行拼接，但要注意的是，在 Go 语言中字符串是不可变的，也就是说每次修改都会导致字符串创建、销毁、内</description>
    </item>
    
    <item>
      <title>Go Hijack黑科技</title>
      <link>http://maratrix.cn/post/2020/04/14/go-hijack-note/</link>
      <pubDate>Tue, 14 Apr 2020 11:53:21 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/04/14/go-hijack-note/</guid>
      <description>最近在看Go标准库里面的rpc源码，发现了下面一段代码： // ServeHTTP implements an http.Handler that answers RPC requests. func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) { if req.Method != &amp;quot;CONNECT&amp;quot; { w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;text/plain; charset=utf-8&amp;quot;) w.WriteHeader(http.StatusMethodNotAllowed) io.WriteString(w, &amp;quot;405 must CONNECT\n&amp;quot;) return } conn, _, err := w.(http.Hijacker).Hijack() //注意看这里 if err != nil { log.Print(&amp;quot;rpc hijacking &amp;quot;, req.RemoteAddr, &amp;quot;: &amp;quot;, err.Error()) return } io.WriteString(conn, &amp;quot;HTTP/1.0 &amp;quot;+connected+&amp;quot;\n\n&amp;quot;) server.ServeConn(conn) } 这是一段接管 HTTP 连接的代码，所谓的接管 HTTP 连接是指这里接管了 HTTP 的 TCP 连接，也就是说 Golang 的内置 HTTP 库和 HTTPServer 库将不</description>
    </item>
    
    <item>
      <title>Nginx基于权重的轮询算法实现</title>
      <link>http://maratrix.cn/post/2020/04/14/smooth-weighted-round-robin/</link>
      <pubDate>Tue, 14 Apr 2020 11:47:28 +0800</pubDate>
      
      <guid>http://maratrix.cn/post/2020/04/14/smooth-weighted-round-robin/</guid>
      <description>Nginx平滑的基于权重轮询算法描述为： Algorithm is as follows: on each peer selection we increase current_weight of each eligible peer by its weight, select peer with greatest current_weight and reduce its current_weight by total number of weight points distributed among peers. 算法执行2步，选择出1个当前节点： 每个节点，用它们的当前值加上它们自己的权重。 选择当前值最大的节点为选中节点，并把它的当前值减去所有节点的权重总和。 例如{a:5, b:1, c:</description>
    </item>
    
  </channel>
</rss>